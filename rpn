# define operations with numbers
def op_pow(stack):
	b = stack.pop()
	a = stack.pop()
	stack.append(a ** b)


def op_mul(stack):
	b = stack.pop()
	a = stack.pop()
	stack.append(a * b)


def op_div(stack):
	b = stack.pop()
	a = stack.pop()
	stack.append(a / b)


def op_add(stack):
	b = stack.pop()
	a = stack.pop()
	stack.append(a + b)


def op_sub(stack):
	b = stack.pop()
	a = stack.pop()
	stack.append(a - b)


#add number to stack
def op_num(stack, num):
	stack.append(num)

#operations
ops = {
	'^': op_pow,
	'*': op_mul,
	'/': op_div,
	'+': op_add,
	'-': op_sub,
}


#Inputs in expression and returns list of tokens
def get_input(inp=None):
	tokens = inp.strip().split()
	return tokens


def rpn_calc(tokens):
	stack = []
	printed_stack = ['TOKEN,STACK'.split(',')]
	for token in tokens:
		if token in ops:
			#apply operation
			ops[token](stack)
			printed_stack.append((token, ' '.join(str(s) for s in stack)))
		else:
			#push number into stack
			op_num(stack, eval(token))
			printed_stack.append((token, ' '.join(str(s) for s in stack)))
	print ('1st element is token, 2nd is stack %r' % printed_stack[1:])
	return stack


if __name__ == '__main__':
	rpn = '5 8 3 + *'
	print( 'expression: %r' % rpn )
	rp = rpn_calc(get_input(rpn))
	print ('answer: %r' % rp[0])
